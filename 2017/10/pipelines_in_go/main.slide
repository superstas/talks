Pipelines in Go 
Based on io.Reader/io.Writer
14 Oct 2017

Afanasev Stanislav
Gopher, Juno
@superstas88

* Agenda

- io.Reader
- io.Writer
- Pipelines ( _reader1|writer2|reader3|..._ )
- Usage patterns

.image ./images/gopher_0.png

* io.Reader

* io.Reader
.code ./misc/interfaces.go /0 OMIT/,/END 0 OMIT/
.image ./images/reader.gif

* io.Reader - Why?
1. Why not bytes.Buffer?

2. The most popular categories:

- wrappers ( stats, metrics, progress, modification, etc. )
- custom buffers with complex logic
- encrypters/decrypters


Based on more than 500 custom readers:
.link https://superstas.github.io/io_stats/

* io.Reader#1
.code ./misc/interfaces.go /1 OMIT/,/END 1 OMIT/
- it's a strict contract!
- _0<=n<=len(p)_ - one of the most important rule
- stdlib wrappers *believe* ( sometimes ) to implementations

Examples:
.link https://golang.org/src/bytes/buffer.go#L210 bytes.Buffer believes
.link https://golang.org/src/bufio/bufio.go#L200 bufio.Reader doesn't believe


* io.Reader#1 - Examples
- ReaderOverflow
.code ./code/reader_infinite.go /1 OMIT/,/END 1 OMIT/
.play -edit ./code/reader_overflow.go /0 OMIT/,/END 0 OMIT/

- ReaderUnlimitedMemory
.play ./code/reader_unlimited_memory.go /0 OMIT/,/END 0 OMIT/

- ReaderInfinite
.play ./code/reader_infinite.go /0 OMIT/,/END 0 OMIT/


* io.Reader#2
.code ./misc/interfaces.go /2 OMIT/,/END 2 OMIT/

- *io.EOF* - "EOF is the error returned by Read when no more input is available"
- *io.ErrUnexpectedEOF*
- *io.ErrNoProgress* - "...usually the sign of a broken io.Reader implementation"

* io.Reader#3
.code ./misc/interfaces.go /4 OMIT/,/END 4 OMIT/
- `return`0,`nil` - *isn't*equal*to* `io.EOF`

 return 0<=n<=len(p), nil - reading is not finished, read again		
 return 0<=n<=len(p), io.EOF - reading is finished		
 return 0, io.EOF - reading is finished ( a special case )

* io.Reader. Mistakes

1. Is there actually a problem here?

- "no readers, no problems"

2. The most common mistakes

- always returning nil error
- trust in wrapped io.Reader
- common logic mistakes


Based on more than 500 custom readers:
.link https://superstas.github.io/io_stats/

* io.Writer

* io.Writer
.code ./misc/interfaces.go /6 OMIT/,/END 6 OMIT/
.image ./images/writer.gif

* io.Writer
.code ./misc/interfaces.go /6_1 OMIT/,/END 6_1 OMIT/
- _0<=n<=len(p)_ - n - written bytes
- writer must return error if it returns n < len(p)
- writer mustn't modify p
- don't retain buffer, copy it if needed


* Implementations

* Implementations of "io" pkg. Circular dendrogram
.image ./images/implementations_qr_code.png
.link https://superstas.github.io/io_interfaces_1.9.html https://superstas.github.io/io_interfaces_1.9.html

* Pipelines

* reader1|reader2 - stdin data
- os.Stdin is a *os.File that implements io.Reader
.code ./code/pipelines/readers/readers.go /1 OMIT/,/END 1 OMIT/

- read stdin via ioutil.ReadAll(io.Reader)
.play ./code/pipelines/example0.go /1 OMIT/,/END 1 OMIT/


* reader1|reader2 - stdin data limitation
- io.LimitedReader wraps io.Reader
- it reads limited amount of bytes
.code ./misc/interfaces.go /9 OMIT/,/END 9 OMIT/

- read limited stdin data
.play ./code/pipelines/example1.go /1 OMIT/,/END 1 OMIT/

* reader1|writer1 - TeeReader
- io.TeeReader
.play ./code/pipelines/example2.go /1 OMIT/,/END 1 OMIT/

* reader1|writer1 - Only writing
- Beginner way
.play ./code/pipelines/example3.go /1 OMIT/,/END 1 OMIT/

* reader1|writer1 - io.Copy
- use `io.Copy`/`io.CopyBuffer`/`io.CopyN`
- `io.Copy` creates 32kb buffer by default
.play ./code/pipelines/example4.go /1 OMIT/,/END 1 OMIT/

* reader1|writer1 - WriterTo and ReaderFrom
.code ./misc/interfaces.go /7 OMIT/,/END 7 OMIT/
.link https://golang.org/src/io/io.go?s=5697:6450#L163 GoDoc
.link https://golang.org/src/io/io.go#L379 io.Copy

.image ./images/gopher2.png

* writer1|reader1
- `io.Pipe`rocks
#TODO Pipe image

#TODO Read data|Gzip|Upload
Diff between bytes.Buffer and io.Pipe

#.play ./code/pipelines/example1.go /3 OMIT/,/END 3 OMIT/
.image ./images/gopher1.png

* Final example

* Find | Grep | Log | Compress | Save
- Step 1: Find something and return io.Reader
.code ./code/pipelines/example8.go /1 OMIT/,/END 1 OMIT/
.code ./code/pipelines/example8.go /2 OMIT/,/END 2 OMIT/

* Find | Grep | Log | Compress | Save
- Step 2: Grep
.code ./code/pipelines/example8.go /3 OMIT/,/END 3 OMIT/

- Step 3: Log
.code ./code/pipelines/example8.go /4 OMIT/,/END 4 OMIT/

- Step 4: Compress and Save
.code ./code/pipelines/example8.go /5 OMIT/,/END 5 OMIT/
.play ./code/pipelines/example8.go /6 OMIT/,/END 6 OMIT/

* Other implementations
.link https://github.com/msoap/byline https://github.com/msoap/byline - Converter io.Reader to line-by-line reader
.link https://github.com/mitchellh/ioprogress https://github.com/mitchellh/ioprogress - Progress bar for io.Reader/io.Writer
.link https://github.com/davecheney/reader https://github.com/davecheney/reader - Open anything as an io.Reader
.link https://github.com/andrewstuart/limio https://github.com/andrewstuart/limio - A rate limiting library
.link https://github.com/facebookgo/counting https://github.com/facebookgo/counting - Counting for io.Reader/io.Writer
.link https://github.com/disorganizer/brig/blob/master/util/std.go#L193 TimeoutReaderWriter 

* Conclusions
- implement io.Reader/io.Writer as needed
- implement io.ReaderFrom/io.WriterTo to avoid redundant allocations
- read documentations 
- stdlib has good implementations

Links:
.link https://golang.org/src/io/io.go https://golang.org/src/io/io.go
.link https://golang.org/src/bytes/buffer.go https://golang.org/src/bytes/buffer.go
.link https://golang.org/src/bytes/reader.go https://golang.org/src/bytes/reader.go
.link https://golang.org/src/net/net.go#L177 https://golang.org/src/net/net.go
