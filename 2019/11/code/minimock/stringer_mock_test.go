package code

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fmt.Stringer -o ./stringer_mock_test.go

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StringerMock implements fmt.Stringer
type StringerMock struct {
	t minimock.Tester

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mStringerMockString
}

// NewStringerMock returns a mock for fmt.Stringer
func NewStringerMock(t minimock.Tester) *StringerMock {
	m := &StringerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.StringMock = mStringerMockString{mock: m}

	return m
}

type mStringerMockString struct {
	mock               *StringerMock
	defaultExpectation *StringerMockStringExpectation
	expectations       []*StringerMockStringExpectation
}

// StringerMockStringExpectation specifies expectation struct of the Stringer.String
type StringerMockStringExpectation struct {
	mock *StringerMock

	results *StringerMockStringResults
	Counter uint64
}

// StringerMockStringResults contains results of the Stringer.String
type StringerMockStringResults struct {
	s1 string
}

// Expect sets up expected params for Stringer.String
func (mmString *mStringerMockString) Expect() *mStringerMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("StringerMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &StringerMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the Stringer.String
func (mmString *mStringerMockString) Inspect(f func()) *mStringerMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for StringerMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by Stringer.String
func (mmString *mStringerMockString) Return(s1 string) *StringerMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("StringerMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &StringerMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &StringerMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the Stringer.String method
func (mmString *mStringerMockString) Set(f func() (s1 string)) *StringerMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the Stringer.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the Stringer.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements fmt.Stringer
func (mmString *StringerMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the StringerMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to StringerMock.String.")
	return
}

// StringAfterCounter returns a count of finished StringerMock.String invocations
func (mmString *StringerMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of StringerMock.String invocations
func (mmString *StringerMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *StringerMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *StringerMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StringerMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to StringerMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to StringerMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StringerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StringerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StringerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockStringDone()
}
